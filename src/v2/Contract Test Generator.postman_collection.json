{
	"info": {
		"_postman_id": "0aea1b32-b8a3-42ae-be65-d509e926516e",
		"name": "(Generator) Contract Tests - OAS2 / Swagger",
		"description": "This collection will automatically generate a series of tests against an OpenAPI2 / Swagger definition that is within your API Builder in Postman or supplied from an external URL.\n\n## Getting Started\n\nRead the documentation on the [Contract Testing Public Workspace](https://postman.postman.co/workspace/0bc7d76d-b582-45ba-b216-5da2c1d174a0) to get started.\n\n## Running this collection\n\nFirstly, make sure you have set up your environment variables by forking [this environment](https://postman.postman.co/workspace/Contract-Test-Generator~0bc7d76d-b582-45ba-b216-5da2c1d174a0/environment/18354885-1125d62a-154a-45a6-8b04-73073e8e4d16). Once completed, this collection can be run using the Postman collection runner or from Newman.\n\n### Change Log\n\n#### 2024-08-15\n\n- Added support for APIs in Postman that are linked with Git repositories.\n    \n- Fixed a bug where numbers were being tested with string values.\n    \n\n#### 2024-06-14\n\n- Merged PR [#15](https://github.com/postman-solutions-eng/postman-contract-test-generator/pull/15)\n    \n- Updated the generator to remove deprecated Postman V9 endpoints in favor of Postman v10 API endpoints.\n    \n- Added support for new `env-apiId` and `env-apiDefinitionId` environment variables that allow users to set a specific Postman API ID that is present in the supplied workspace to be processed by the test generator.\n    \n\n**Breaking Changes:**\n\nThe update to the v10 API endpoints results in the following changes required by users:\n\n- When referencing an API from Postman, the API **must** either have a [published version](https://learning.postman.com/docs/designing-and-developing-your-api/versioning-an-api/api-versions/) inside Postman, or the environment must supply the new `env-apiId` and `env-apiDefinitionId` parameters.\n    \n- This does not affect users that reference external schemas from the `env-schemaUrl` environment variable.\n    \n- Users that don't have a published version, or supply the parameters will receive an error: `API must have a published version or a definitionId provided`.\n    \n\n#### 2023-10-01\n\n- Added support for the env-schemaUrl environment variable enabling you to supply a URL to a JSON or YAML based schema for validation.\n    \n- Various bug fixes and improvements for performance.\n    \n\n## Support\n\nThis collection is maintained in GitHub by the Postman Solutions Engineering team. Please post an issue directly in [this GitHub project](https://github.com/postman-solutions-eng/postman-contract-test-generator) if you need support.",
		"schema": "https://schema.getpostman.com/json/collection/v2.1.0/collection.json",
		"_exporter_id": "18354885",
		"_collection_link": "https://postman.postman.co/workspace/Contract-Test-Generator---OAS2-~c3ed36bd-a29e-496c-be25-3bf6b0c9d171/collection/18354885-0aea1b32-b8a3-42ae-be65-d509e926516e?action=share&source=collection_link&creator=18354885"
	},
	"item": [
		{
			"name": "API Validation",
			"item": [
				{
					"name": "Initialize",
					"item": [
						{
							"name": "Cleanup Previous Run",
							"event": [
								{
									"listen": "prerequest",
									"script": {
										"exec": [
											"// See https://blog.postman.com/2019/05/28/pro-tip-dynamically-unset-postman-environment-variables/\r",
											"// for more details on what we're doing here. \r",
											"\r",
											"cleanupCollectionVariables();\r",
											"\r",
											"function cleanupCollectionVariables() {\r",
											"    const clean = _.keys(pm.collectionVariables.toObject());\r",
											"\r",
											"    _.each(clean, (arrItem) => {\r",
											"        pm.collectionVariables.unset(arrItem);\r",
											"    });\r",
											"}"
										],
										"type": "text/javascript"
									}
								},
								{
									"listen": "test",
									"script": {
										"exec": [
											""
										],
										"type": "text/javascript"
									}
								}
							],
							"request": {
								"method": "GET",
								"header": [],
								"url": {
									"raw": "https://postman-echo.com/delay/0",
									"protocol": "https",
									"host": [
										"postman-echo",
										"com"
									],
									"path": [
										"delay",
										"0"
									]
								}
							},
							"response": []
						},
						{
							"name": "Initialize",
							"event": [
								{
									"listen": "test",
									"script": {
										"exec": [
											"const providedSchema = pm.environment.get('env-schema');\r",
											"const providedSchemaUrl = pm.environment.get('env-schemaUrl');\r",
											"if(providedSchemaUrl && providedSchemaUrl != \"\") {\r",
											"    postman.setNextRequest(\"Get Schema From URL\");\r",
											"} else if(providedSchema){\r",
											"    let success = true;\r",
											"    try{\r",
											"        const yaml = pm.environment.get('env-jsonToYaml');\r",
											"        (new Function(yaml))();\r",
											"\r",
											"        const schema = jsyaml.load(providedSchema);\r",
											"        pm.collectionVariables.set('coll-schema', JSON.stringify(schema));\r",
											"        postman.setNextRequest('Get API Base Url');\r",
											"    }\r",
											"    catch(err){\r",
											"        console.log(err);\r",
											"        success = false;\r",
											"        postman.setNextRequest(null);\r",
											"    }\r",
											"\r",
											"    pm.test('Successfully converted provided schema', function(){\r",
											"        pm.expect(success).to.be.true;\r",
											"    });    \r",
											"} else {\r",
											"    postman.setNextRequest(\"Validate API In Workspace\")\r",
											"}"
										],
										"type": "text/javascript",
										"packages": {}
									}
								}
							],
							"request": {
								"method": "GET",
								"header": [],
								"url": {
									"raw": "https://postman-echo.com/delay/0",
									"protocol": "https",
									"host": [
										"postman-echo",
										"com"
									],
									"path": [
										"delay",
										"0"
									]
								}
							},
							"response": []
						}
					]
				},
				{
					"name": "Get Schema from URL",
					"item": [
						{
							"name": "Get Schema From URL",
							"event": [
								{
									"listen": "test",
									"script": {
										"exec": [
											"let responseSchema = pm.response.text();",
											"",
											"if(responseSchema.length != 0) {",
											"    let success = true;",
											"    try{",
											"        const yaml = pm.environment.get('env-jsonToYaml');",
											"        (new Function(yaml))();",
											"",
											"        const schema = jsyaml.load(responseSchema);",
											"        pm.collectionVariables.set('coll-schema', JSON.stringify(schema));",
											"        postman.setNextRequest('Get API Base Url');",
											"    }",
											"    catch(err){",
											"        console.log(err);",
											"        success = false;",
											"        postman.setNextRequest(null);",
											"    }",
											"",
											"    pm.test('Successfully converted provided schema', function(){",
											"        pm.expect(success).to.be.true;",
											"    }); ",
											"} else {",
											"    console.log(\"Error retrieving schema from URL - \" + pm.environment.get(\"env-schemaUrl\"));",
											"    postman.setNextRequest(null);",
											"}",
											"",
											""
										],
										"type": "text/javascript"
									}
								}
							],
							"request": {
								"method": "GET",
								"header": [],
								"url": {
									"raw": "{{env-schemaUrl}}",
									"host": [
										"{{env-schemaUrl}}"
									]
								}
							},
							"response": []
						}
					]
				},
				{
					"name": "Get Schema from Postman",
					"item": [
						{
							"name": "Validate API In Workspace",
							"event": [
								{
									"listen": "test",
									"script": {
										"exec": [
											"//2024-06-07 - Added new environment variable for targeting specific API ID\r",
											"let targetApiId = pm.environment.get('env-apiId');\r",
											"let apiIds = [];\r",
											"\r",
											"if(targetApiId && targetApiId != \"\") {\r",
											"    //User has targeted at least 1 API in this workspace.\r",
											"    targetApiId = targetApiId.trim();\r",
											"\r",
											"    //Validate that the API IDs provided exist in this workspace.\r",
											"    let workspaceApiIds = pm.response.json().apis.map(api => api.id);\r",
											"\r",
											"    console.log(workspaceApiIds);\r",
											"\r",
											"    pm.test(`Validate that API ${targetApiId} exists in this workspace.`, function () {    \r",
											"        pm.expect(workspaceApiIds, \"Your env-apiIds variable includes an invalid API ID\").to.include(targetApiId);\r",
											"    });\r",
											"\r",
											"    apiIds = [targetApiId];\r",
											"\r",
											"    pm.test(`There is at least 1 API to process`, function() {\r",
											"        pm.expect(apiIds).to.have.length.greaterThan(0);\r",
											"    });\r",
											"\r",
											"} else {\r",
											"    const minApiCount = Number(pm.environment.get('env-minApiCount'));\r",
											"    const maxApiCount = Number(pm.environment.get('env-maxApiCount'));\r",
											"    const jsonData = pm.response.json();\r",
											"\r",
											"    pm.test(`Workspace API count is between ${minApiCount} and ${maxApiCount}. (Count: ${jsonData.apis.length})`, function () {    \r",
											"        pm.expect(jsonData.apis.length).to.be.at.least(minApiCount);    \r",
											"        pm.expect(jsonData.apis.length).to.be.at.most(maxApiCount);\r",
											"    });\r",
											"    \r",
											"    _.forEach(jsonData.apis, function(api){\r",
											"        apiIds.push(api.id);\r",
											"    });\r",
											"}\r",
											"\r",
											"pm.collectionVariables.set('coll-apiIds', JSON.stringify(apiIds));"
										],
										"type": "text/javascript",
										"packages": {}
									}
								}
							],
							"request": {
								"auth": {
									"type": "noauth"
								},
								"method": "GET",
								"header": [
									{
										"key": "X-Api-Key",
										"value": "{{env-apiKey}}"
									},
									{
										"key": "Accept",
										"value": "application/vnd.api.v10+json"
									}
								],
								"url": {
									"raw": "https://api.getpostman.com/apis?workspaceId={{env-workspaceId}}",
									"protocol": "https",
									"host": [
										"api",
										"getpostman",
										"com"
									],
									"path": [
										"apis"
									],
									"query": [
										{
											"key": "workspaceId",
											"value": "{{env-workspaceId}}"
										}
									]
								}
							},
							"response": []
						},
						{
							"name": "Get Current API Version",
							"event": [
								{
									"listen": "test",
									"script": {
										"exec": [
											"const jsonData = pm.response.json();\r",
											"let latestVersionId;\r",
											"let apiDefinitionId;\r",
											"\r",
											"//set the latest version\r",
											"if(jsonData && jsonData.versions && jsonData.versions.length > 0) {\r",
											"    latestVersionId = jsonData.versions[0].id;\r",
											"}\r",
											"\r",
											"if(latestVersionId) {\r",
											"    pm.collectionVariables.set('coll-versionId', latestVersionId);\r",
											"} \r",
											"\r",
											"//We have no published versions - see if we can get the schema via the supplied definitionId\r",
											"apiId = pm.environment.get(\"env-apiId\");\r",
											"apiDefinitionId = pm.environment.get(\"env-apiDefinitionId\");\r",
											"\r",
											"if(apiId && apiDefinitionId && apiId != \"\" && apiDefinitionId != \"\") {\r",
											"    pm.collectionVariables.set(\"coll-schemaId\", apiDefinitionId);\r",
											"    postman.setNextRequest(\"Get API Schema\");\r",
											"}\r",
											"\r",
											"pm.test(\"API must have at least 1 version published or a definitionId provided.\", function() {\r",
											"    postman.setNextRequest(null);\r",
											"    pm.expect(latestVersionId || apiDefinitionId, \"API does not have a published version, and no definitionId is available in the environment\").to.not.be.undefined;\r",
											"    \r",
											"    if (apiDefinitionId) {\r",
											"        postman.setNextRequest(\"Get API Schema\")\r",
											"    } else if(latestVersionId) {\r",
											"        postman.setNextRequest(\"Get Current API Schema\");\r",
											"    }\r",
											"})"
										],
										"type": "text/javascript",
										"packages": {}
									}
								},
								{
									"listen": "prerequest",
									"script": {
										"exec": [
											"let apiIds = pm.collectionVariables.get('coll-apiIds');\r",
											"if(apiIds){\r",
											"    apiIds = JSON.parse(apiIds);\r",
											"    const apiId = apiIds.pop();\r",
											"\r",
											"    pm.collectionVariables.set('coll-apiId', apiId);\r",
											"    pm.collectionVariables.set('coll-apiIds', JSON.stringify(apiIds));\r",
											"}\r",
											"else {\r",
											"    pm.request.url = 'https://postman-echo.com/delay/0'\r",
											"    pm.request.name = 'No APIs found in the workspace. Skipping execution';\r",
											"    postman.setNextRequest(null);\r",
											"}"
										],
										"type": "text/javascript",
										"packages": {}
									}
								}
							],
							"request": {
								"auth": {
									"type": "noauth"
								},
								"method": "GET",
								"header": [
									{
										"key": "X-Api-Key",
										"value": "{{env-apiKey}}"
									},
									{
										"key": "Accept",
										"value": "application/vnd.api.v10+json"
									}
								],
								"url": {
									"raw": "https://api.getpostman.com/apis/:apiId/versions",
									"protocol": "https",
									"host": [
										"api",
										"getpostman",
										"com"
									],
									"path": [
										"apis",
										":apiId",
										"versions"
									],
									"query": [
										{
											"key": null,
											"value": "",
											"disabled": true
										}
									],
									"variable": [
										{
											"key": "apiId",
											"value": "{{coll-apiId}}"
										}
									]
								}
							},
							"response": []
						},
						{
							"name": "Get Current API Schema",
							"event": [
								{
									"listen": "test",
									"script": {
										"exec": [
											"const jsonData = pm.response.json();\r",
											"\r",
											"pm.test('Has schema for current version', function(){\r",
											"    pm.expect(jsonData).to.have.property('schemas').and.to.be.an(\"Array\");\r",
											"    pm.expect(jsonData.schemas.length).to.be.above(0);\r",
											"\r",
											"    pm.collectionVariables.set('coll-schemaId', jsonData.schemas[0].id);\r",
											"});"
										],
										"type": "text/javascript",
										"packages": {}
									}
								},
								{
									"listen": "prerequest",
									"script": {
										"exec": [
											""
										],
										"type": "text/javascript",
										"packages": {}
									}
								}
							],
							"request": {
								"auth": {
									"type": "noauth"
								},
								"method": "GET",
								"header": [
									{
										"key": "X-Api-Key",
										"value": "{{env-apiKey}}"
									},
									{
										"key": "Accept",
										"value": "application/vnd.api.v10+json"
									}
								],
								"url": {
									"raw": "https://api.getpostman.com/apis/:apiId/versions/:versionId",
									"protocol": "https",
									"host": [
										"api",
										"getpostman",
										"com"
									],
									"path": [
										"apis",
										":apiId",
										"versions",
										":versionId"
									],
									"query": [
										{
											"key": null,
											"value": "",
											"disabled": true
										}
									],
									"variable": [
										{
											"key": "apiId",
											"value": "{{coll-apiId}}"
										},
										{
											"key": "versionId",
											"value": "{{coll-versionId}}"
										}
									]
								}
							},
							"response": []
						},
						{
							"name": "Get API Schema",
							"event": [
								{
									"listen": "test",
									"script": {
										"exec": [
											"\r",
											"let code = pm.response.code;\r",
											"\r",
											"if (code == 422) {\r",
											"    //Git linked API - use fallback instead.\r",
											"    postman.setNextRequest(\"Get API Schema (v9 fallback)\");\r",
											"} else {\r",
											"\r",
											"    try {\r",
											"        const jsonData = pm.response.json();\r",
											"        pm.test('Schema is JSON', function () {\r",
											"            pm.expect(jsonData).to.have.property(\"content\");\r",
											"            pm.expect(jsonData.content).to.not.be.null;\r",
											"            pm.collectionVariables.set('coll-schema', jsonData.content);\r",
											"        });\r",
											"\r",
											"    }\r",
											"    catch (err) {\r",
											"        console.log(err);\r",
											"        pm.test('Unable to load schema', function () {\r",
											"            pm.expect(0).to.equal(1);\r",
											"            postman.setNextRequest(null);\r",
											"        })\r",
											"    }\r",
											"}\r",
											"\r",
											""
										],
										"type": "text/javascript",
										"packages": {}
									}
								}
							],
							"request": {
								"auth": {
									"type": "noauth"
								},
								"method": "GET",
								"header": [
									{
										"key": "X-Api-Key",
										"value": "{{env-apiKey}}"
									},
									{
										"key": "Accept",
										"value": "application/vnd.api.v10+json"
									}
								],
								"url": {
									"raw": "https://api.getpostman.com/apis/:apiId/schemas/:schemaId?bundled=true",
									"protocol": "https",
									"host": [
										"api",
										"getpostman",
										"com"
									],
									"path": [
										"apis",
										":apiId",
										"schemas",
										":schemaId"
									],
									"query": [
										{
											"key": "bundled",
											"value": "true"
										}
									],
									"variable": [
										{
											"key": "apiId",
											"value": "{{coll-apiId}}"
										},
										{
											"key": "schemaId",
											"value": "{{coll-schemaId}}"
										}
									]
								}
							},
							"response": []
						},
						{
							"name": "Get API Schema (v9 fallback)",
							"event": [
								{
									"listen": "test",
									"script": {
										"exec": [
											"try {\r",
											"    let jsonData = pm.response.json();\r",
											"    \r",
											"    if(jsonData.api && jsonData.api.versions && jsonData.api.versions.length > 0 && jsonData.api.versions[0].schemas && jsonData.api.versions[0].schemas.length > 0) {\r",
											"        \r",
											"        pm.test('Schema is valid', function() {\r",
											"        \r",
											"            jsonData = jsonData.api.versions[0].schemas[0];\r",
											"\r",
											"            pm.expect(jsonData).to.have.property(\"content\");\r",
											"            pm.expect(jsonData.content).to.not.be.null;\r",
											"\r",
											"            let schema = null;\r",
											"            let colSchema = null;\r",
											"\r",
											"            if(jsonData.language && jsonData.language == \"yaml\") {\r",
											"                const yaml = pm.environment.get('env-jsonToYaml');\r",
											"                (new Function(yaml))();\r",
											"\r",
											"                schema = jsyaml.load(jsonData.content);\r",
											"                colSchema = JSON.stringify(schema);\r",
											"                postman.setNextRequest('Get API Base Url');\r",
											"            } else if(jsonData.language && jsonData.language == \"json\") {\r",
											"                colSchema = jsonData.content;\r",
											"            }\r",
											"\r",
											"            pm.expect(colSchema).to.not.be.null;\r",
											"            pm.collectionVariables.set('coll-schema', colSchema);\r",
											"            postman.setNextRequest(\"Get API Base Url\")\r",
											"        });\r",
											"    }\r",
											"}\r",
											"catch(err) {\r",
											"    console.log(err);\r",
											"    pm.test('Unable to load schema', function(){\r",
											"        pm.expect(0).to.equal(1);\r",
											"        postman.setNextRequest(null);\r",
											"    })\r",
											"}"
										],
										"type": "text/javascript",
										"packages": {}
									}
								}
							],
							"request": {
								"auth": {
									"type": "noauth"
								},
								"method": "GET",
								"header": [
									{
										"key": "X-Api-Key",
										"value": "{{env-apiKey}}"
									}
								],
								"url": {
									"raw": "https://api.getpostman.com/apis/:apiId",
									"protocol": "https",
									"host": [
										"api",
										"getpostman",
										"com"
									],
									"path": [
										"apis",
										":apiId"
									],
									"variable": [
										{
											"key": "apiId",
											"value": "{{coll-apiId}}"
										}
									]
								}
							},
							"response": []
						}
					]
				},
				{
					"name": "Get API Base Url",
					"event": [
						{
							"listen": "test",
							"script": {
								"exec": [
									"const schema = JSON.parse(pm.collectionVariables.get('coll-schema'));\r",
									"const server = pm.environment.get('env-server');\r",
									"\r",
									"pm.test('Environment has test server defined', function () {\r",
									"    pm.expect(server).to.not.be.undefined;\r",
									"});\r",
									"\r",
									"const schemes = schema.schemes;\r",
									"const host = schema.host;\r",
									"var basepath = schema.basePath;\r",
									"\r",
									"pm.test('Schema has at least 1 scheme', function () {\r",
									"    pm.expect(schemes).to.not.be.undefined;\r",
									"    pm.expect(schemes).to.be.an(\"array\");\r",
									"    pm.expect(schemes).to.have.lengthOf.at.least(1);\r",
									"})\r",
									"\r",
									"pm.test(\"schema has a defined host\", function() {\r",
									"    pm.expect(host).to.not.be.undefined;\r",
									"    pm.expect(host).to.be.a(\"string\");\r",
									"})\r",
									"\r",
									"pm.test(\"schema has a defined basepath\", function() {\r",
									"    if(basepath) {\r",
									"        pm.expect(basepath).to.be.a(\"string\");\r",
									"        pm.expect(basepath).to.contain(\"/\");\r",
									"    } else {\r",
									"        basepath = \"\";\r",
									"    }\r",
									"})\r",
									"    \r",
									"pm.collectionVariables.set('coll-baseUrl', `${schemes[0]}://${host}${basepath}`);\r",
									"\r",
									"\r",
									"const runComponentTests = pm.environment.get('env-runComponentTests') == 'true';\r",
									"if(!runComponentTests){   \r",
									"    const runContractTests = pm.environment.get('env-runContractTests') == 'true';\r",
									"    if(runContractTests){\r",
									"        postman.setNextRequest('Build Schema Tests');\r",
									"    } else {\r",
									"        postman.setNextRequest('More APIs to Process?');\r",
									"    }   \r",
									"}"
								],
								"type": "text/javascript"
							}
						}
					],
					"request": {
						"auth": {
							"type": "noauth"
						},
						"method": "GET",
						"header": [],
						"url": {
							"raw": "https://postman-echo.com/delay/0",
							"protocol": "https",
							"host": [
								"postman-echo",
								"com"
							],
							"path": [
								"delay",
								"0"
							]
						}
					},
					"response": []
				}
			]
		},
		{
			"name": "Definitions",
			"item": [
				{
					"name": "Verify Definition Adherence",
					"event": [
						{
							"listen": "test",
							"script": {
								"exec": [
									"const schema = JSON.parse(pm.collectionVariables.get('coll-schema'));\r",
									"\r",
									"const requireParamDescription = Boolean(pm.environment.get('env-requireParamDescription'));\r",
									"const requireParamExample = Boolean(pm.environment.get('env-requireParamExample'));\r",
									"\r",
									"let paramDescriptionMinLength = pm.environment.get('env-paramDescriptionMinLength');\r",
									"if (paramDescriptionMinLength) {\r",
									"    paramDescriptionMinLength = Number(paramDescriptionMinLength);\r",
									"}\r",
									"\r",
									"let paramDescriptionMaxLength = pm.environment.get('env-paramDesciptionMaxLength');\r",
									"if (paramDescriptionMaxLength) {\r",
									"    paramDescriptionMaxLength = Number(paramDescriptionMaxLength);\r",
									"}\r",
									"\r",
									"var testedSchemaRefs = [];\r",
									"if (schema.definitions) {\r",
									"    for (let prop in schema.definitions) {\r",
									"        pm.test(`Schema '${prop}' begins with an uppercase letter`, function () {\r",
									"            pm.expect(prop.charAt(0)).to.equal(prop.charAt(0).toUpperCase());\r",
									"        });\r",
									"\r",
									"        const testedSchema = testedSchemaRefs.find(tsr => tsr == prop);\r",
									"        if (!testedSchema) {\r",
									"            const schemaObject = schema.definitions[prop];\r",
									"            testSchemaObject(schema, schemaObject, prop);\r",
									"            testedSchemaRefs.push(prop);\r",
									"        }\r",
									"    }\r",
									"}\r",
									"const runContractTests = pm.environment.get('env-runContractTests') == 'true';\r",
									"if (runContractTests) {\r",
									"    postman.setNextRequest('Build Schema Tests');\r",
									"} else {\r",
									"    postman.setNextRequest('More APIs to Process?');\r",
									"}\r",
									"\r",
									"\r",
									"function testSchemaObject(schema, object, objectName) {\r",
									"    if (object.type && object.type.toLowerCase() == 'object') {\r",
									"        if (object.required) {\r",
									"            for (let i = 0; i < object.required.length; i++) {\r",
									"                const requiredProp = object.required[i];\r",
									"                pm.test(`Schema '${objectName}' has required property '${requiredProp}' defined`, function () {\r",
									"                    pm.expect(object.properties).to.have.property(requiredProp);\r",
									"                });\r",
									"            }\r",
									"        }\r",
									"\r",
									"        let schemaPropertyExceptions = [];\r",
									"        if (pm.environment.has('env-schemaPropertyExceptions')) {\r",
									"            schemaPropertyExceptions = JSON.parse(pm.environment.get('env-schemaPropertyExceptions'));\r",
									"        }\r",
									"\r",
									"        for (let prop in object.properties) {\r",
									"            const property = object.properties[prop];\r",
									"\r",
									"            if (!schemaPropertyExceptions.some(pe => pe === prop)) {\r",
									"                pm.test(`Schema property '${objectName}.${prop}' is lowercase`, function () {\r",
									"                    pm.expect(prop.charAt(0)).to.equal(prop.charAt(0).toLowerCase());\r",
									"                });\r",
									"            }\r",
									"\r",
									"            if (property.type && property.type.toLowerCase() == 'object') {\r",
									"                testSchemaObject(schema, property, `${objectName}.${prop}`);\r",
									"            }\r",
									"            else if (property.type && property.type.toLowerCase() == 'array') {\r",
									"                testSchemaObject(schema, property, `${objectName}.${prop}(list)`);\r",
									"            }\r",
									"            else if (property.oneOf) {\r",
									"                _.forEach(property.oneOf, (oneOf, i) => {\r",
									"                    testSchemaObject(schema, oneOf, `${objectName}.${prop}(oneOf).${i}`)\r",
									"                });\r",
									"            }\r",
									"            else if (property.allOf) {\r",
									"                _.forEach(property.allOf, (allOf, i) => {\r",
									"                    testSchemaObject(schema, allOf, `${objectName}.${prop}(allOf).${i}`)\r",
									"                });\r",
									"            }\r",
									"            else if (property.anyOf) {\r",
									"                _.forEach(property.anyOf, (anyOf, i) => {\r",
									"                    testSchemaObject(schema, anyOf, `${objectName}.${prop}(anyOf).${i}`)\r",
									"                });\r",
									"            }\r",
									"            else {\r",
									"                if (requireParamDescription && !property.$ref) {\r",
									"                    pm.test(`Schema property '${objectName}.${prop}' has a description between ${paramDescriptionMinLength} and ${paramDescriptionMaxLength} characters`, function () {\r",
									"                        pm.expect(property).to.have.property('description').and.to.be.a('string');\r",
									"                        pm.expect(property.description.length).to.be.at.least(paramDescriptionMinLength);\r",
									"                        pm.expect(property.description.length).to.be.at.most(paramDescriptionMaxLength);\r",
									"                    });\r",
									"\r",
									"                    if (property.description) {\r",
									"                        pm.test(`Schema property '${objectName}.${prop}' description is not just the name`, function () {\r",
									"                            pm.expect(prop.toLowerCase()).to.not.equal(property.description.toLowerCase());\r",
									"                        });\r",
									"                    }\r",
									"                }\r",
									"\r",
									"                if (requireParamExample && !property.$ref) {\r",
									"                    pm.test(`Schema property '${objectName}.${prop}' has an example`, function () {\r",
									"                        pm.expect(property).to.have.property('example');\r",
									"                    });\r",
									"                }\r",
									"            }\r",
									"        }\r",
									"    }\r",
									"    else if (object.type && object.type.toLowerCase() == 'array') {\r",
									"        pm.test(`Schema '${objectName}' has items defined`, function () {\r",
									"            pm.expect(object).to.have.property('items');\r",
									"        });\r",
									"\r",
									"        testSchemaObject(schema, object.items, `${objectName}.list`);\r",
									"    }\r",
									"    else if (object.oneOf) {\r",
									"        handleSchemaArray(schema, object, objectName, 'oneOf');\r",
									"    } else if (object.allOf) {\r",
									"        handleSchemaArray(schema, object, objectName, 'allOf');\r",
									"    }\r",
									"    else if (object.anyOf) {\r",
									"        handleSchemaArray(schema, object, objectName, 'anyOf');\r",
									"    }\r",
									"    else if (object.$ref) {\r",
									"        const name = getName(object.$ref);\r",
									"        const testedRef = testedSchemaRefs.find(tsr => tsr == name);\r",
									"        if (!testedRef) {\r",
									"            testSchemaObject(schema, schema.definitions[name], objectName);\r",
									"            testedSchemaRefs.push(name);\r",
									"        }\r",
									"    }\r",
									"    else {\r",
									"        pm.test(`Schema '${objectName}' has a declared type`, function () {\r",
									"            pm.expect(object).to.have.property('type');\r",
									"        });\r",
									"    }\r",
									"}\r",
									"\r",
									"function handleSchemaArray(schema, object, objectName, arrayType) {\r",
									"    for (let i = 0; i < object[arrayType].length; i++) {\r",
									"        const arraySchema = object[arrayType][i];\r",
									"        if (arraySchema.$ref) {\r",
									"            const name = getName(arraySchema.$ref);\r",
									"            const testedRef = testedSchemaRefs.find(tsr => tsr == name);\r",
									"            if (!testedRef) {\r",
									"                testSchemaObject(schema, schema.definitions[name], `${objectName}[${i}](ref ${name})`);\r",
									"                testedSchemaRefs.push(name);\r",
									"            }\r",
									"        }\r",
									"        else {\r",
									"            testSchemaObject(schema, arraySchema, `${objectName}[${i}]`);\r",
									"        }\r",
									"    }\r",
									"}\r",
									"\r",
									"function getName(ref) {\r",
									"    let pieces = ref.split('/');\r",
									"    return pieces[pieces.length - 1];\r",
									"}\r",
									""
								],
								"type": "text/javascript"
							}
						}
					],
					"request": {
						"auth": {
							"type": "noauth"
						},
						"method": "GET",
						"header": [],
						"url": {
							"raw": "https://postman-echo.com/delay/0",
							"protocol": "https",
							"host": [
								"postman-echo",
								"com"
							],
							"path": [
								"delay",
								"0"
							]
						}
					},
					"response": []
				}
			]
		},
		{
			"name": "Contract Tests",
			"item": [
				{
					"name": "Build Schema Tests",
					"event": [
						{
							"listen": "prerequest",
							"script": {
								"exec": [
									"const schema = JSON.parse(pm.collectionVariables.get('coll-schema'))\r",
									"\r",
									"let schemaTests = []\r",
									"\r",
									"//Iterate the Paths\r",
									"\r",
									"for (let prop in schema.paths) {\r",
									"    const pathName = prop\r",
									"    let path = {\r",
									"        path: `${pm.collectionVariables.get('coll-baseUrl')}${pathName}`,\r",
									"        parameters: schema.paths[prop].parameters,\r",
									"    }\r",
									"\r",
									"    //Iterate the Methods\r",
									"\r",
									"    for (let method in schema.paths[prop]) {\r",
									"\r",
									"        if (\r",
									"            method.toLowerCase() == 'parameters' ||\r",
									"            isMockEndpoint(schema.paths[prop][method])\r",
									"        ) {\r",
									"            continue\r",
									"        }\r",
									"        let currentPath = _.cloneDeep(path)\r",
									"        currentPath.method = method.toUpperCase()\r",
									"        let pathMethod = schema.paths[prop][method]\r",
									"        let securityExtension = pm.environment.get('env-securityExtensionName')\r",
									"        if (\r",
									"            securityExtension &&\r",
									"            pathMethod[securityExtension] &&\r",
									"            pathMethod[securityExtension].length > 0\r",
									"        ) {\r",
									"            currentPath.allowedRole = pathMethod[securityExtension][0]\r",
									"        }\r",
									"        if (pathMethod.parameters && pathMethod.parameters.length > 0) {\r",
									"            if (currentPath.parameters) {\r",
									"                currentPath.parameters = pathMethod.parameters.concat(pathMethod.parameters, currentPath.parameters);\r",
									"            } else {\r",
									"                currentPath.parameters = pathMethod.parameters;\r",
									"            }\r",
									"        }\r",
									"\r",
									"        const expectedResponses = getExpectedResponses(pathMethod)\r",
									"        currentPath.responses = expectedResponses\r",
									"\r",
									"        let bodyParameter;\r",
									"        let requestParameters = [];\r",
									"\r",
									"        if (pathMethod.parameters) {\r",
									"\r",
									"            for (let i = 0; i < pathMethod.parameters.length; i++) {\r",
									"                let thisParameter = pathMethod.parameters[i];\r",
									"\r",
									"                if (thisParameter && thisParameter.in && thisParameter.in.toLowerCase() == \"body\") {\r",
									"                    bodyParameter = thisParameter;\r",
									"                } else if (thisParameter && thisParameter.in && (thisParameter.in.toLowerCase() == \"header\" || thisParameter.in.toLowerCase() == \"query\" || thisParameter.in.toLowerCase() == \"path\")) {\r",
									"                    requestParameters.push(thisParameter);\r",
									"                }\r",
									"            }\r",
									"        }\r",
									"\r",
									"        if (bodyParameter) {\r",
									"\r",
									"            let bodyModel = {};\r",
									"            if (bodyParameter && bodyParameter.schema && bodyParameter.schema.$ref) {\r",
									"                bodyModel = getSchemaReference(\r",
									"                    schema,\r",
									"                    bodyParameter.schema.$ref\r",
									"                )\r",
									"            } else {\r",
									"                bodyModel = bodyParameter && bodyParameter.schema ? bodyParameter.schema : {};\r",
									"            }\r",
									"\r",
									"            const models = buildModels(schema, bodyModel)\r",
									"            const mutations = buildModelMutations(models)\r",
									"\r",
									"            mutations.forEach(mutation => {\r",
									"                let schemaTest = _.cloneDeep(currentPath)\r",
									"                Object.assign(schemaTest, mutation)\r",
									"                schemaTest.name = `${schemaTest.method} - ${pathName} - ${schemaTest.description} - SUCCESS: ${schemaTest.success}`\r",
									"                schemaTest.parameters = requestParameters;\r",
									"                schemaTests.push(schemaTest)\r",
									"            })\r",
									"        } else {\r",
									"            currentPath.name = `${currentPath.method} - ${pathName} - No Request Body - SUCCESS: true`\r",
									"            currentPath.success = true\r",
									"            currentPath.parameters = requestParameters;\r",
									"            schemaTests.push(currentPath)\r",
									"        }\r",
									"    }\r",
									"}\r",
									"\r",
									"pm.collectionVariables.set('coll-schemaTests', JSON.stringify(schemaTests))\r",
									"//\r",
									"// Supporting Methods Below\r",
									"//\r",
									"function buildModels(schema, object) {\r",
									"    let models = []\r",
									"\r",
									"    if (object['$ref']) {\r",
									"        object = getSchemaReference(schema, object['$ref'])\r",
									"    }\r",
									"\r",
									"    if (object.type && object.type.toLowerCase() == 'object') {\r",
									"        if (object.required && object.required.length > 0) {\r",
									"            models.push({})\r",
									"            _.forEach(object.required, function (param) {\r",
									"                const property = object.properties[param]\r",
									"\r",
									"                try {\r",
									"                    let type = property.type;\r",
									"                } catch (ex) {\r",
									"                    throw new Error(`A required property referenced in one of your definitions was not available in the properties: ${param}`);\r",
									"                }\r",
									"\r",
									"                if (\r",
									"                    property.type &&\r",
									"                    ['string', 'number', 'integer', 'boolean'].includes(\r",
									"                        property.type.toLowerCase()\r",
									"                    )\r",
									"                ) {\r",
									"                    for (let modelIndex = 0; modelIndex < models.length; modelIndex++) {\r",
									"                        let model = models[modelIndex]\r",
									"                        model[param] = property.example\r",
									"                    }\r",
									"                } else {\r",
									"                    const nestedObjects = buildModels(schema, property)\r",
									"                    models = addToModels(models, nestedObjects, param)\r",
									"                }\r",
									"            })\r",
									"        }\r",
									"    } else if (object.type && object.type.toLowerCase() == 'array') {\r",
									"        let items = buildModels(schema, object.items)\r",
									"        if (Array.isArray(items)) {\r",
									"            for (let i = 0; i < items.length; i++) {\r",
									"                models.push([items[i]])\r",
									"            }\r",
									"        } else {\r",
									"            models.push([items])\r",
									"        }\r",
									"    } else if (object.oneOf) {\r",
									"        _.forEach(object.oneOf, function (component) {\r",
									"            let items = buildModels(schema, component)\r",
									"            models = models.concat(items)\r",
									"        })\r",
									"    } else if (object.allOf) {\r",
									"        let pieces = [{}]\r",
									"        _.forEach(object.allOf, function (component) {\r",
									"            let componentModels = buildModels(schema, component)\r",
									"            pieces = addToModels(pieces, componentModels)\r",
									"        })\r",
									"\r",
									"        models = pieces\r",
									"    } else if (object.anyOf) {\r",
									"        let pieces = []\r",
									"        let combinedPieces = [{}]\r",
									"        _.forEach(object.anyOf, function (component) {\r",
									"            let componentModels = buildModels(schema, component)\r",
									"            combinedPieces = addToModels(combinedPieces, componentModels)\r",
									"            pieces = pieces.concat(componentModels)\r",
									"        })\r",
									"\r",
									"        models = pieces.concat(combinedPieces)\r",
									"    } else {\r",
									"        // All other options are primitive values\r",
									"        return object.example\r",
									"    }\r",
									"    return models\r",
									"}\r",
									"\r",
									"function getSchemaReference(schema, referenceName) {\r",
									"    const refPieces = referenceName.split('/')\r",
									"    let reference = schema\r",
									"    for (let i = 1; i < refPieces.length; i++) {\r",
									"        reference = reference[refPieces[i]]\r",
									"    }\r",
									"\r",
									"    return reference\r",
									"}\r",
									"\r",
									"function addToModels(models, newPieces, name) {\r",
									"    let newModels = []\r",
									"    _.forEach(models, function (model) {\r",
									"        _.forEach(newPieces, function (newPiece) {\r",
									"            let newModel = _.cloneDeep(model)\r",
									"            if (name) {\r",
									"                newModel[name] = newPiece\r",
									"            } else {\r",
									"                Object.assign(newModel, newPiece)\r",
									"            }\r",
									"            newModels.push(newModel)\r",
									"        })\r",
									"    })\r",
									"\r",
									"    return newModels\r",
									"}\r",
									"\r",
									"function buildModelMutations(models) {\r",
									"    let modelMutations = []\r",
									"    _.forEach(models, function (model) {\r",
									"        addMutation(true, 'Has all required fields', model, modelMutations)\r",
									"        let mutations = buildMutation(model)\r",
									"        modelMutations = modelMutations.concat(mutations)\r",
									"    })\r",
									"\r",
									"    return modelMutations\r",
									"}\r",
									"\r",
									"function buildMutation(model) {\r",
									"    let mutations = []\r",
									"\r",
									"    for (const [key, value] of Object.entries(model)) {\r",
									"        if (typeof value == 'object') {\r",
									"            let nestedMutations = buildMutation(value)\r",
									"            nestedMutations.forEach(nestedMutation => {\r",
									"                let mutation = _.cloneDeep(model)\r",
									"                mutation[key] = nestedMutation.body\r",
									"                addMutation(\r",
									"                    false,\r",
									"                    `${nestedMutation.description} in ${key} object`,\r",
									"                    mutation,\r",
									"                    mutations\r",
									"                )\r",
									"            })\r",
									"\r",
									"            let mutation = _.cloneDeep(model)\r",
									"            delete mutation[key]\r",
									"            addMutation(false, `Missing ${key} object`, mutation, mutations)\r",
									"\r",
									"            let emptyMutation = _.cloneDeep(model)\r",
									"            emptyMutation[key] = {}\r",
									"            addMutation(false, `Empty ${key} object`, emptyMutation, mutations)\r",
									"        } else {\r",
									"            if (Array.isArray(value)) {\r",
									"                console.log('probably an error')\r",
									"            }\r",
									"\r",
									"            if (typeof model[key] == \"string\") {\r",
									"                let blankMutation = _.cloneDeep(model)\r",
									"                blankMutation[key] = ''\r",
									"                addMutation(false, `Blank ${key} property`, blankMutation, mutations)\r",
									"            }\r",
									"\r",
									"            let mutation = _.cloneDeep(model)\r",
									"            delete mutation[key]\r",
									"            addMutation(false, `Missing ${key} property`, mutation, mutations)\r",
									"        }\r",
									"    }\r",
									"\r",
									"    return mutations\r",
									"}\r",
									"\r",
									"function addMutation(isSuccess, description, mutation, mutations) {\r",
									"    mutations.push({\r",
									"        success: isSuccess,\r",
									"        description: description,\r",
									"        body: mutation\r",
									"    })\r",
									"}\r",
									"\r",
									"function getExpectedResponses(pathMethod) {\r",
									"    const responses = []\r",
									"    for (const [statusCode, value] of Object.entries(pathMethod.responses)) {\r",
									"        let response = {\r",
									"            statusCode: Number(statusCode)\r",
									"        }\r",
									"\r",
									"        if (value.schema && value.schema.$ref) {\r",
									"            response.$ref = value.schema.$ref\r",
									"        } else {\r",
									"            //check if it's an array\r",
									"            if (\r",
									"                value.schema &&\r",
									"                value.schema.type &&\r",
									"                value.schema.type.toLowerCase() == 'array'\r",
									"            ) {\r",
									"                response.schema = value.schema\r",
									"            }\r",
									"        }\r",
									"\r",
									"        if (value['x-postman-variables']) {\r",
									"            response.variables = value['x-postman-variables'];\r",
									"        }\r",
									"\r",
									"        responses.push(response)\r",
									"    }\r",
									"    return responses\r",
									"}\r",
									"\r",
									"function isMockEndpoint(pathMethod) {\r",
									"    let isMock = false\r",
									"    if (\r",
									"        pathMethod &&\r",
									"        pathMethod['x-amazon-apigateway-integration'] &&\r",
									"        pathMethod['x-amazon-apigateway-integration'].type &&\r",
									"        pathMethod['x-amazon-apigateway-integration'].type.toLowerCase() == 'mock'\r",
									"    ) {\r",
									"        isMock = true\r",
									"    }\r",
									"\r",
									"    return isMock\r",
									"}"
								],
								"type": "text/javascript",
								"packages": {}
							}
						},
						{
							"listen": "test",
							"script": {
								"exec": [
									"let schemaTests = pm.collectionVariables.get('coll-schemaTests');\r",
									"if(schemaTests){\r",
									"    schemaTests = JSON.parse(schemaTests);\r",
									"    if(!schemaTests || !schemaTests.length){\r",
									"        postman.setNextRequest('More APIs to Process?');\r",
									"    }\r",
									"}"
								],
								"type": "text/javascript",
								"packages": {}
							}
						}
					],
					"request": {
						"auth": {
							"type": "noauth"
						},
						"method": "GET",
						"header": [],
						"url": {
							"raw": "https://postman-echo.com/delay/0",
							"protocol": "https",
							"host": [
								"postman-echo",
								"com"
							],
							"path": [
								"delay",
								"0"
							]
						}
					},
					"response": []
				},
				{
					"name": "Test Request",
					"event": [
						{
							"listen": "prerequest",
							"script": {
								"exec": [
									"const url = require('url');\r",
									"\r",
									"const schema = JSON.parse(pm.collectionVariables.get('coll-schema'));\r",
									"let schemaTests = JSON.parse(pm.collectionVariables.get('coll-schemaTests'));\r",
									"\r",
									"const schemaTest = schemaTests.shift();\r",
									"pm.collectionVariables.set('coll-schemaTests', JSON.stringify(schemaTests));\r",
									"pm.variables.set('currentSchemaTest', JSON.stringify(schemaTest));\r",
									"\r",
									"const path = replacePathParameters(schema, schemaTest.path, schemaTest.parameters);\r",
									"pm.request.url.update(path);\r",
									"delete pm.request.url.auth;\r",
									"delete pm.request.url.port;\r",
									"delete pm.request.url.hash;\r",
									"pm.request.url.protocol = pm.request.url.protocol.replace(/\\:$/, '');\r",
									"pm.request.method = schemaTest.method;\r",
									"pm.request.name = schemaTest.name;\r",
									"\r",
									"pm.variables.set('requestName', schemaTest.name);\r",
									"pm.variables.set('body', JSON.stringify(schemaTest.body));\r",
									"\r",
									"// Add top level parameters from the path\r",
									"const roleHeaderName = pm.environment.get('env-roleHeaderName');\r",
									"\r",
									"if(schemaTest.parameters){\r",
									"    for(let i = 0; i < schemaTest.parameters.length; i++){\r",
									"        let param = schemaTest.parameters[i];\r",
									"\r",
									"        if (param.$ref) {\r",
									"            let pieces = param.$ref.split('/');\r",
									"            const name = pieces[pieces.length-1];\r",
									"            const schemaParam = schema.components.parameters[name];\r",
									"            const paramType = schemaParam.in.toLowerCase();\r",
									"            const paramValue = loadParameterValue(schemaParam);\r",
									"            if(paramType == 'header'){\r",
									"                if(roleHeaderName && schemaParam.name.toLowerCase() == roleHeaderName.toLowerCase()){\r",
									"                    pm.request.headers.upsert({ key: schemaParam.name, value: schemaTest.allowedRole });    \r",
									"                } \r",
									"                else {\r",
									"                    pm.request.headers.upsert({ key: schemaParam.name, value: paramValue });\r",
									"                }\r",
									"            } else if (paramType == 'query' && schemaParam.required == true) {\r",
									"                pm.request.url.query.upsert({ key: schemaParam.name, value: paramValue });\r",
									"            }\r",
									"        } else {\r",
									"            const paramType = param.in.toLowerCase();\r",
									"            const paramValue = loadParameterValue(param);\r",
									"            if (paramType == 'header') {\r",
									"                pm.request.headers.upsert({ key: param.name, value: paramValue });\r",
									"            } else if (paramType == 'query' && param.required == true) {\r",
									"                pm.request.url.query.upsert({ key: param.name, value: paramValue });\r",
									"            }\r",
									"        }\r",
									"    }\r",
									"}\r",
									"\r",
									"function loadParameterValue(parameter){\r",
									"    let parameterValue;\r",
									"    if(parameter['x-postman-variables']){\r",
									"        let variable = parameter['x-postman-variables'].find(v => v.type.toLowerCase() === 'load');\r",
									"        if(variable && pm.collectionVariables.has(variable.name)){\r",
									"            parameterValue = pm.collectionVariables.get(variable.name);\r",
									"        }\r",
									"        else {\r",
									"            parameterValue = encodeURIComponent(parameter.example);    \r",
									"        }\r",
									"    }\r",
									"    else {\r",
									"        parameterValue = encodeURIComponent(parameter.example);\r",
									"    }\r",
									"\r",
									"    return parameterValue;\r",
									"}\r",
									"\r",
									"function replacePathParameters(schema, pathName, parameters){\r",
									"    let replacedPathName = pathName;\r",
									"    let pathVariableRegex = /{([^}]*)}/g;\r",
									"    let matches = pathName.match(pathVariableRegex);\r",
									"    _.forEach(matches, function(match){\r",
									"        let paramName = match.substring(1, match.length - 1);\r",
									"        _.forEach(parameters, function(param){\r",
									"            if(param.$ref){\r",
									"                let parameter = getSchemaReference(schema, param.$ref);                \r",
									"                if (parameter.in && parameter.in.toLowerCase() == 'path' && parameter.name && parameter.name == paramName){\r",
									"                    let parameterValue = loadParameterValue(parameter);\r",
									"                    replacedPathName = replacedPathName.replace(match, parameterValue);\r",
									"                    return false;\r",
									"                }\r",
									"            } else {\r",
									"                if (param.in && param.in.toLowerCase() == 'path' && param.name && param.name == paramName) {\r",
									"                    let parameterValue = loadParameterValue(param);\r",
									"                    replacedPathName = replacedPathName.replace(match, parameterValue);\r",
									"                    return false;\r",
									"                }\r",
									"            }\r",
									"        });    \r",
									"    });\r",
									"\r",
									"    return url.parse(replacedPathName);\r",
									"}\r",
									"\r",
									"function getSchemaReference(schema, referenceName){  \r",
									"  const refPieces = referenceName.split('/');\r",
									"  let reference = schema;\r",
									"  for(let i = 1; i < refPieces.length; i++){\r",
									"    reference = reference[refPieces[i]];\r",
									"  }\r",
									"\r",
									"  return reference;  \r",
									"}"
								],
								"type": "text/javascript",
								"packages": {}
							}
						},
						{
							"listen": "test",
							"script": {
								"exec": [
									"const schemaTests = JSON.parse(pm.collectionVariables.get('coll-schemaTests'));\r",
									"if(schemaTests.length > 0){\r",
									"    postman.setNextRequest('Test Request');\r",
									"}\r",
									"\r",
									"const schemaTest = JSON.parse(pm.variables.get('currentSchemaTest'));\r",
									"\r",
									"pm.test(`${schemaTest.name} - Has expected status code`, function () {\r",
									"    if(schemaTest.success){\r",
									"        pm.expect(pm.response.code).to.not.equal(400);\r",
									"    }\r",
									"    else {\r",
									"        const statusCode = pm.response.code;\r",
									"        pm.expect(statusCode === 400 || statusCode === 422).to.be.true;\r",
									"    }    \r",
									"});\r",
									"\r",
									"\r",
									"const expectedResponse = schemaTest.responses.find(r => r.statusCode == pm.response.code);\r",
									"pm.test(`${schemaTest.name} - Status code is allowed`, function(){\r",
									"    pm.expect(expectedResponse).to.exist;\r",
									"});\r",
									"\r",
									"if(expectedResponse){\r",
									"    pm.test(`${schemaTest.name} - Has expected response body schema`, function(){\r",
									"        const Ajv = require('ajv');\r",
									"        const ajv = new Ajv({allErrors: true,format: false,nullable: true});\r",
									"        \r",
									"        if(pm.response.code == 204 || shouldResponseBeEmpty(expectedResponse)){\r",
									"            checkForEmptyResponse();\r",
									"        } else if(expectedResponse.$ref) {     \r",
									"            const jsonData = pm.response.json();\r",
									"            const schema = JSON.parse(pm.collectionVariables.get('coll-schema'));\r",
									"            ajv.addSchema(schema, 'OAS');\r",
									"            \r",
									"            const valid = ajv.validate({$ref: `OAS${expectedResponse.$ref}`}, jsonData);\r",
									"            const errors = ajv.errorsText(valid.errors);\r",
									"            pm.expect(errors).to.equal('No errors');\r",
									"            if(errors !== 'No errors'){\r",
									"                console.log(errors);\r",
									"            }\r",
									"        }\r",
									"        else if(expectedResponse.schema && expectedResponse.schema.type && expectedResponse.schema.type === 'array' && expectedResponse.schema.items && expectedResponse.schema.items.$ref){\r",
									"            const jsonData = pm.response.json();\r",
									"            const schema = JSON.parse(pm.collectionVariables.get('coll-schema'));\r",
									"            ajv.addSchema(schema, 'OAS');\r",
									"            expectedResponse.schema.items.$ref = `OAS${expectedResponse.schema.items.$ref}`\r",
									"            const valid = ajv.validate(expectedResponse.schema, jsonData);\r",
									"            const errors = ajv.errorsText(valid.errors);\r",
									"            pm.expect(errors).to.equal('No errors');\r",
									"            if(errors !== 'No errors'){\r",
									"                console.log(errors);\r",
									"            }\r",
									"        }\r",
									"        else if(expectedResponse.schema){\r",
									"            const jsonData = pm.response.json();\r",
									"            const validate = ajv.compile(expectedResponse.schema);\r",
									"            const valid = validate(jsonData);\r",
									"            const errors = ajv.errorsText(valid.errors);\r",
									"            pm.expect(errors).to.equal('No errors');\r",
									"            if(errors !== 'No errors'){\r",
									"                console.log(errors);\r",
									"            }\r",
									"        }\r",
									"        else {\r",
									"            checkForEmptyResponse();\r",
									"        }\r",
									"        \r",
									"        if(expectedResponse.variables){\r",
									"            const jsonData = pm.response.json();\r",
									"            _.forEach(expectedResponse.variables, function(variable){\r",
									"                let pathPieces = variable.path.split('.').filter(piece => piece);\r",
									"                let data = jsonData;\r",
									"                let found = true;\r",
									"                _.forEach(pathPieces, function(piece){\r",
									"                    if(data[piece]){\r",
									"                        data = data[piece];\r",
									"                    }\r",
									"                    else {\r",
									"                        found = false;\r",
									"                    }\r",
									"                });\r",
									"\r",
									"                if(found){\r",
									"                    pm.collectionVariables.set(variable.name, data);\r",
									"                }\r",
									"                else {\r",
									"                    pm.test(`Unable to save dynamic variable ${variable.name} at the provided path.`, function() {\r",
									"                        pm.expect(true).to.equal(variable.path);\r",
									"                    });\r",
									"                }\r",
									"            });\r",
									"        }\r",
									"    });\r",
									"}\r",
									"\r",
									"function checkForEmptyResponse() {\r",
									"    let emptyBody = true;\r",
									"    if(pm.response.text()){\r",
									"        emptyBody = false; \r",
									"    }\r",
									"\r",
									"    pm.expect(emptyBody).to.be.true;\r",
									"}\r",
									"\r",
									"function shouldResponseBeEmpty(expectedResponse){\r",
									"    let responseSchema = expectedResponse.schema;\r",
									"    if(expectedResponse.$ref){\r",
									"        let schema = JSON.parse(pm.collectionVariables.get('coll-schema'));\r",
									"        responseSchema = getSchemaReference(schema, expectedResponse.$ref);\r",
									"        if(expectedResponse.$ref.startsWith('#/components/responses')){\r",
									"            return (!responseSchema || !responseSchema.content || !responseSchema.content['application/json'] \r",
									"                || !responseSchema.content['application/json'].schema || Object.keys(responseSchema.content['application/json'].schema).length == 0);\r",
									"        } else {\r",
									"            return false;\r",
									"        }\r",
									"    }\r",
									"    else {\r",
									"        return (Object.keys(responseSchema).length == 0);\r",
									"    }\r",
									"}\r",
									"\r",
									"function getSchemaReference(schema, referenceName){  \r",
									"  const refPieces = referenceName.split('/');\r",
									"  let reference = schema;\r",
									"  for(let i = 1; i < refPieces.length; i++){\r",
									"    reference = reference[refPieces[i]];\r",
									"  }\r",
									"\r",
									"  return reference;  \r",
									"}"
								],
								"type": "text/javascript",
								"packages": {}
							}
						}
					],
					"protocolProfileBehavior": {
						"disableBodyPruning": true
					},
					"request": {
						"method": "GET",
						"header": [],
						"body": {
							"mode": "raw",
							"raw": "{{body}}",
							"options": {
								"raw": {
									"language": "json"
								}
							}
						},
						"url": {
							"raw": "https://postman-echo.com/get",
							"protocol": "https",
							"host": [
								"postman-echo",
								"com"
							],
							"path": [
								"get"
							]
						}
					},
					"response": []
				}
			]
		},
		{
			"name": "Finalize",
			"item": [
				{
					"name": "More APIs to Process?",
					"event": [
						{
							"listen": "test",
							"script": {
								"exec": [
									"let apis = pm.collectionVariables.get('coll-apiIds');\r",
									"if(apis){\r",
									"    try{\r",
									"        apis = JSON.parse(apis);\r",
									"        if(apis.length > 0){\r",
									"            postman.setNextRequest('Get Current API Version');\r",
									"        }\r",
									"    }\r",
									"    catch(err){}    \r",
									"}"
								],
								"type": "text/javascript"
							}
						}
					],
					"request": {
						"auth": {
							"type": "noauth"
						},
						"method": "GET",
						"header": [],
						"url": {
							"raw": "https://postman-echo.com/delay/0",
							"protocol": "https",
							"host": [
								"postman-echo",
								"com"
							],
							"path": [
								"delay",
								"0"
							]
						}
					},
					"response": []
				},
				{
					"name": "Remove Test Variables",
					"event": [
						{
							"listen": "prerequest",
							"script": {
								"exec": [
									"// See https://blog.postman.com/2019/05/28/pro-tip-dynamically-unset-postman-environment-variables/\r",
									"// for more details on what we're doing here. \r",
									"\r",
									"cleanupCollectionVariables();\r",
									"\r",
									"function cleanupCollectionVariables() {\r",
									"    const clean = _.keys(pm.collectionVariables.toObject());\r",
									"\r",
									"    _.each(clean, (arrItem) => {\r",
									"        pm.collectionVariables.unset(arrItem);\r",
									"    });\r",
									"}"
								],
								"type": "text/javascript"
							}
						},
						{
							"listen": "test",
							"script": {
								"exec": [
									""
								],
								"type": "text/javascript"
							}
						}
					],
					"request": {
						"method": "GET",
						"header": [],
						"url": {
							"raw": "https://postman-echo.com/delay/0",
							"protocol": "https",
							"host": [
								"postman-echo",
								"com"
							],
							"path": [
								"delay",
								"0"
							]
						}
					},
					"response": []
				}
			]
		}
	],
	"event": [
		{
			"listen": "prerequest",
			"script": {
				"type": "text/javascript",
				"exec": [
					""
				]
			}
		},
		{
			"listen": "test",
			"script": {
				"type": "text/javascript",
				"exec": [
					""
				]
			}
		}
	]
}